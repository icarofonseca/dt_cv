<!DOCTYPE html>
<html lang="en">

<head>

	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="">
	<meta name="author" content="">

	<title>Digital Twin</title>

	<!-- Bootstrap Core CSS -->
	<link href="libs/bootstrap.min.css" rel="stylesheet">

	<!-- jQuery Version 1.11.1 -->
	<script src="libs/jquery.js"></script>

	<!-- Bootstrap Core JavaScript -->
	<script src="libs/bootstrap.min.js"></script>

	<!-- Three script -->
	<script src="libs/three.js"></script>
	<script src="libs/STLLoader.js"></script>
	<script src="libs/Mirror.js"></script>
	<script src="libs/WaterShader.js"></script>
	<!-- <script src="libs/OrbitControls.js"></script> -->
	<script src="libs/skybox_from_examples.js"></script>
	<script src="snippets/Patch_interpolation.js"></script>
	<script src="snippets/Regular_ocean.js"></script>

	<script src="libs/adapter-5.0.4.js" type="text/javascript"></script>
	<script src="utils.js" type="text/javascript"></script>
</head>

<body>

	<!-- Navigation -->
	<nav class="navbar navbar-inverse">
		<div class="container">
			<!-- Add  the <div>[Something]</div> structure for each header in the navbar-->
			<div class="navbar-header">
				<a class="navbar-brand" href="https://github.com/shiplab/vesseljs">Github page</a>
			</div>
			<!-- This is for the right part of the navbar. Reserved for Shiplab logo-->
			<div class="nav navbar-nav navbar-right">
				<div class="navbar-header">
					<a class="navbar-brand" href="http://www.shiplab.hials.org/"><img src="images/logo.png"
							alt="Shiplab logo" style="height:150%">
					</a>
				</div>
			</div>
		</div>
	</nav>

	<!-- Container creates the space -->
	<div class="container">

		<!-- Row creates horizontal groups of columns -->
		<div class="row">
			<div class="col-md-12 text-center">
				<h2>Digital Twin</h2>
				<p>Interactive version of the ECMS paper.</p>
			</div>

			<div>
				<div class="control"><button id="startAndStop" disabled>Start</button></div>
			</div>
			<p class="err" id="errorMessage"></p>

			<div class="row">
				<div class="col">
					<canvas id="canvasOutput" style="float:left;width:50%;height:360"></canvas>
				</div>
				<div id="3d" class="col-sm-6" style="float:right;width:50%;min-height:300px">
				</div>
			</div>

			<!-- <p>x position (free oscillation)</p>
			<div id="x_motion" style="width:100%;height:200px"></div> -->

			<video id="videoInput" width=320 height=240></video>

			<div id="hereresult"></div>
		</div>

	</div>
	</div>

	<script>
		"use strict";

		var xCenter, yCenter;
		var resolution = {
			w: 320,
			h: 240
		};

		var m = 30; // kg
		var k = 20; // N/m
		var c = 2.9; // (N*s)/m
		var initX = [1, 0]; // X = [initial position in m, initial velocity in m/s]

		// // x = [xdot, xdotdot]
		// function freeMotion(t, x) {
		// 	var F = 0; // N
		// 	var xdotdot = (F - c * x[1] - k * x[0]) / m;
		// 	return [x[1], xdotdot];
		// };

		// var tmax = 100; // s
		// var sol_free = numeric.dopri(0, tmax, initX, freeMotion);
		// var x_motion = numeric.rep([sol_free.x.length, 2], 0);

		// for (var i = 0; i < sol_free.x.length; i++) {
		// 	x_motion[i][0] = sol_free.x[i];
		// 	x_motion[i][1] = sol_free.y[i][0];
		// }

		// $.plot("#x_motion", [x_motion], {
		// 	xaxis: {
		// 		tickFormatter: function (val, axis) {
		// 			return val < axis.max ? val.toFixed(2) : "time (s)";
		// 		}
		// 	},
		// 	yaxis: {
		// 		tickFormatter: function (val, axis) {
		// 			return val < axis.max ? val.toFixed(2) : "position (m)";
		// 		},
		// 	}
		// });

		var renderer, container, scene, camera, controls;
		var zUpCont, ocean;

		//Ready renderer and scene
		(function () {
			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setClearColor(0xA9CCE3, 1);

			// get the div that will hold the renderer
			container = document.getElementById('3d');
			// add the renderer to the div
			container.appendChild(renderer.domElement);

			//Scene setup:
			scene = new THREE.Scene();
			let sun = new THREE.DirectionalLight(0xffffff, 2);
			sun.position.set(-512, 246, 128);
			scene.add(sun);

			//Ocean size: aquarium is circa 40 cm on its longer dimension and 20 cm on the shorter
			let length = 20;
			let width = 40;
			let oSize = 40;

			scene.add(new Skybox(width, length));

			//Use Z up from now on:
			THREE.Object3D.DefaultUp.set(0, 0, 1);
			zUpCont = new THREE.Group();
			zUpCont.rotation.x = -0.5 * Math.PI;
			scene.add(zUpCont);

			//Camera and controls:
			camera = new THREE.PerspectiveCamera(26, window.innerWidth / window.innerHeight, 1, 1000000);
			camera.up.set(0, 0, 1);
			scene.add(camera);
			//controls = new THREE.OrbitControls(camera, renderer.domElement);

			camera.position.set(0, 0, 50);
			//controls.target = new THREE.Vector3(0, 0, 0);
			camera.lookAt(zUpCont.position);
			zUpCont.add(camera);
			camera.rotation.z = - Math.PI;

			zUpCont.add(new THREE.HemisphereLight(0xccccff, 0x666688, 1));

			ocean = new Ocean({
				sunDir: sun.position.clone().normalize(),
				size: oSize,
				length: length,
				width: width,
				segments: 127,
			});
			zUpCont.add(ocean);

			//Respond to window resize:
			function onResize() {
				renderer.setSize(container.clientWidth, container.clientHeight);
				camera.aspect = container.clientWidth / container.clientHeight;
				camera.updateProjectionMatrix();
			}
			window.addEventListener("resize", onResize);
			onResize(); //Ensure the initial setup is good too
		})();

		var geometry = new THREE.BoxGeometry(7, 12.3, 1);
		var material = new THREE.MeshBasicMaterial({
			color: "yellow"
		});
		var cube = new THREE.Mesh(geometry, material);
		cube.rotation.x = Math.PI / 2;
		cube.rotation.z = Math.PI / 2;
		scene.add(cube);

		var tprev = 0;
		var posX = initX;

		var clock = new THREE.Clock();
		//controls.update();
		animate();

		function animate() {
			var time = clock.getElapsedTime();

			// if (time - tprev !== 0) {
			// 	// solve ODE for the time step
			// 	posX = numeric.dopri(tprev, time, posX, freeMotion).at(time);
			// 	cube.position.x = posX[0];
			// 	tprev = time;
			// }

			// spring.position.x = (cube.position.x + base.position.x) / 2;
			// spring.scale.y = (cube.position.x - base.position.x) / 2;

			// damper.position.x = (cube.position.x + base.position.x) / 2;
			// damper.scale.y = (cube.position.x - base.position.x) / 2;

			ocean.update(time);
			ocean.water.render();

			requestAnimationFrame(animate);
			renderer.render(scene, camera);
		}

		let utils = new Utils('errorMessage');

		let streaming = false;
		let videoInput = document.getElementById('videoInput');
		document.getElementById("videoInput").style.display = "none";
		let startAndStop = document.getElementById('startAndStop');
		let canvasOutput = document.getElementById('canvasOutput');
		let canvasContext = canvasOutput.getContext('2d');

		startAndStop.addEventListener('click', () => {
			if (!streaming) {
				utils.clearError();
				utils.startCamera('qvga', onVideoStarted, 'videoInput');
			} else {
				utils.stopCamera();
				onVideoStopped();
			}
		});

		function onVideoStarted() {
			streaming = true;
			startAndStop.innerText = 'Stop';
			videoInput.width = videoInput.videoWidth;
			videoInput.height = videoInput.videoHeight;
			//utils.executeCode('codeEditor');

			let video = document.getElementById('videoInput');
			let cap = new cv.VideoCapture(video);

			// take first frame of the video
			let frame = new cv.Mat(video.height, video.width, cv.CV_8UC4);
			cap.read(frame);

			// hardcode the initial location of window
			let trackWindow = new cv.Rect(150, 120, 113, 54);

			// set up the ROI for tracking
			let roi = frame.roi(trackWindow);
			let hsvRoi = new cv.Mat();
			cv.cvtColor(roi, hsvRoi, cv.COLOR_RGBA2RGB);
			cv.cvtColor(hsvRoi, hsvRoi, cv.COLOR_RGB2HSV);
			let mask = new cv.Mat();
			let lowScalar = new cv.Scalar(30, 30, 0);
			let highScalar = new cv.Scalar(180, 180, 180);
			let low = new cv.Mat(hsvRoi.rows, hsvRoi.cols, hsvRoi.type(), lowScalar);
			let high = new cv.Mat(hsvRoi.rows, hsvRoi.cols, hsvRoi.type(), highScalar);
			cv.inRange(hsvRoi, low, high, mask);
			let roiHist = new cv.Mat();
			let hsvRoiVec = new cv.MatVector();
			hsvRoiVec.push_back(hsvRoi);
			cv.calcHist(hsvRoiVec, [0], mask, roiHist, [180], [0, 180]);
			cv.normalize(roiHist, roiHist, 0, 255, cv.NORM_MINMAX);

			// delete useless mats.
			roi.delete(); hsvRoi.delete(); mask.delete(); low.delete(); high.delete(); hsvRoiVec.delete();

			// Setup the termination criteria, either 10 iteration or move by atleast 1 pt
			let termCrit = new cv.TermCriteria(cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, 10, 1);

			let hsv = new cv.Mat(video.height, video.width, cv.CV_8UC3);
			let hsvVec = new cv.MatVector();
			hsvVec.push_back(hsv);
			let dst = new cv.Mat();
			let trackBox = null;

			const FPS = 30;
			function processVideo() {
				try {
					if (!streaming) {
						// clean and stop.
						frame.delete(); dst.delete(); hsvVec.delete(); roiHist.delete(); hsv.delete();
						return;
					}
					let begin = Date.now();

					// start processing.
					cap.read(frame);
					cv.cvtColor(frame, hsv, cv.COLOR_RGBA2RGB);
					cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
					cv.calcBackProject(hsvVec, [0], roiHist, dst, [0, 180], 1);

					// apply camshift to get the new location
					[trackBox, trackWindow] = cv.CamShift(dst, trackWindow, termCrit);

					console.log("box", trackBox);
					console.log("window", trackWindow);
					//trackBox.size.height = 54;
					//trackBox.size.width = 113;
					//trackWindow.height = 54;
					//trackWindow.width = 113;

					// Draw it on image
					let pts = cv.rotatedRectPoints(trackBox);
					cv.line(frame, pts[0], pts[1], [255, 0, 0, 255], 3);
					cv.line(frame, pts[1], pts[2], [255, 0, 0, 255], 3);
					cv.line(frame, pts[2], pts[3], [255, 0, 0, 255], 3);
					cv.line(frame, pts[3], pts[0], [255, 0, 0, 255], 3);
					cv.imshow('canvasOutput', frame);

					// locate object center
					xCenter = (trackBox.center.x/*  + w/2 */) - resolution.w / 2;
					yCenter = - (trackBox.center.y/*  + h/2 */) + resolution.h / 2;
					cube.position.x = xCenter * 40 / resolution.w;
					cube.position.z = yCenter * 20 / resolution.h;
					cube.rotation.z = Math.PI / 2 + Math.PI / 180 * (trackBox.angle + 90);

					// schedule the next one.
					let delay = 1000 / FPS - (Date.now() - begin);
					setTimeout(processVideo, delay);
				} catch (err) {
					utils.printError(err);
				}
			};

			// schedule the first one.
			setTimeout(processVideo, 0);
		}

		function onVideoStopped() {
			streaming = false;
			canvasContext.clearRect(0, 0, canvasOutput.width, canvasOutput.height);
			startAndStop.innerText = 'Start';
		}

		utils.loadOpenCv(() => {
			startAndStop.removeAttribute('disabled');
		});

	</script>

</body>

</html>